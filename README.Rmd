---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(jhcutils)
set.seed(0)
```
# jhcutils <a href="https://jhrcook.github.io/jhcutils/index.html"> <img src="man/figures/logo.png" align="right" alt="" width="120" /> </a>

[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)
[![Travis build status](https://travis-ci.org/jhrcook/jhcutils.svg?branch=master)](https://travis-ci.org/jhrcook/jhcutils)
[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/jhrcook/jhcutils?branch=master&svg=true)](https://ci.appveyor.com/project/jhrcook/jhcutils)
[![Coverage status](https://codecov.io/gh/jhrcook/jhcutils/branch/master/graph/badge.svg)](https://codecov.io/github/jhrcook/jhcutils?branch=master)

These are a bunch of functions that I find myself declaring and rewriting in a many scripts and analyses.

## Installation

You can install 'jhcutils' with:

```{r install, eval = FALSE}
devtools::install_github("jhrcook/jhcutils")
```

Full documentation at the ['pkgdown site'](https://jhrcook.github.io/jhcutils/index.html).

---

## General Utilities

**n_unique** - return the number of unique values in a vector.

```{r nunique}
a <- c(1, 2, 2, 3, 4, 5)
n_unique(a)
b <- list(c(1, 2, 3, 4), c(1, 2, 3, 4, 5))
n_unique(b)
n_unique(b, to_unlist = TRUE)
```

**unique_na** - return the unique values in a vector, omitting `NA`.

```{r uniquena}
a <- c(1, 2, 3, NA, 3)
unique_na(a)
b <- list(c(1, 2, 3, NA), c(1, 2, NA, 5))
unique_na(b)
unique_na(b, to_unlist = TRUE)
```

**minmax** - set limits on a vector of numeric values.

```{r minmax}
c <- sample(-100:100, 20)
c
minmax(c, -10, 10)
```


## Tidygraph

```{r myplot, include=FALSE}
library(ggraph)
my_plot_fxn <- function(gr) {
    g <- ggraph(gr, layout = "nicely") +
        geom_edge_link(color = "grey30", width = 0.5) +
        geom_node_point(color = "dodgerblue", size = 7) +
        geom_node_text(aes(label = name), size = 4, color = "black") +
        theme_void()
    return(g)
}
```


**quick_forestfire** - wrapper around `tidygraph::play_forestfire` except that it will return a tidygraph object with the node attribute `"name"`.

```{r forestfire}
forest_gr <- quick_forestfire(10)
forest_gr
my_plot_fxn(forest_gr) +
    labs(title = "Example of a quick Forest Fire graph model")
```

**quick_barabasi** - wrapper around `tidygraph::play_barabasi_albert` except that it will return a tidygraph object with the node attribute `"name"`.

```{r barbasi}
barabasi_gr <- quick_barabasi(10)
barabasi_gr
my_plot_fxn(barabasi_gr) +
    labs(title = "Example of a quick Barabasi-Albert graph")
```

**quick_graph** - randomly selects one of the above random graphs.

```{r quickgraph}
quick_gr <- quick_graph(10)
```

**recursive_graph_join** - recursively join a list of tidygraph objects.

```{r recursivegraphjoin}
gr_list <- purrr::map(c(5, 10, 15), quick_forestfire)
gr <- recursive_graph_join(gr_list)
gr
my_plot_fxn(gr) +
    labs(title = "Example of joining 3 forest fire graphs")
```

**filter_component_size** - filter the components of a tidygraph object by their individual number of nodes (order).

```{r filtercompsize}
gr <- tidygraph::bind_graphs(quick_forestfire(4, name = LETTERS),
                             quick_forestfire(6, name = letters))
igraph::count_components(gr)
igraph::count_components(filter_component_size(gr, min_size = 5))
igraph::count_components(filter_component_size(gr, max_size = 5))
```


## Pacakge Utilities

**document_df** - prints the framework for documenting a data frame object.

```{r documentdf}
dat <- tibble::tibble(x = c(LETTERS[1:5]),
                      y = c(1:5),
                      z = list(rep(list(1:3), 5)))
dat
document_df(dat)
```

---

## Additions

If you have any recommended additions, please open an [issue](https://github.com/jhrcook/jhcutils/issues).
